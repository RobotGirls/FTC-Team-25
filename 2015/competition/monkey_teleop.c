#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     elbow,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     conveyor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     driveRearRight, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     driveFrontRight, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     driveRearLeft, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     driveFrontLeft, tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    roller,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    leftFinger,           tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    rightFinger,          tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

#define SERVO_ROLLER_UP             48
#define SERVO_ROLLER_DOWN           137
#define CONVEYOR_POWER              80
#define LSERVO_DOCK_FINGER_STOWED   82
#define LSERVO_DOCK_FINGER_UP       205
#define LSERVO_DOCK_FINGER_DOWN     161
#define RSERVO_DOCK_FINGER_STOWED   144
#define RSERVO_DOCK_FINGER_UP       0
#define RSERVO_DOCK_FINGER_DOWN     64

static int drive_multiplier = 1;

typedef enum conveyor_state_ {
    CONVEYOR_OFF,
    CONVEYOR_FORWARD,
    CONVEYOR_BACKWARD,
} conveyor_state_t;

typedef enum dock_state_ {
    DOCK_FINGER_UP,
    DOCK_FINGER_DOWN,
    DOCK_FINGER_STOWED,
} dock_state_t;

typedef enum joystick_event_ {
    RIGHT_TRIGGER_UP = 6,
    RIGHT_TRIGGER_DOWN = 8,
    LEFT_TRIGGER_UP = 5,
    LEFT_TRIGGER_DOWN = 7,
    BUTTON_ONE = 1,
    BUTTON_FOUR = 4,
    BUTTON_TEN	= 10,
} joystick_event_t;

conveyor_state_t conveyor_state;
dock_state_t dock_state;

bool debounce;

task debounceTask()
{
    debounce = true;
    wait1Msec(500);
    debounce = false;
}

void all_stop()
{
    motor[driveFrontLeft] = 0;
    motor[driveRearLeft] = 0;
    motor[driveFrontRight] = 0;
    motor[driveRearRight] = 0;
}

void dock_enter_state(dock_state_t state)
{
    dock_state = state;

    switch (state) {
    case DOCK_FINGER_STOWED:
        servo[rightFinger] = RSERVO_DOCK_FINGER_STOWED;
        servo[leftFinger]  = LSERVO_DOCK_FINGER_STOWED;
        break;
    case DOCK_FINGER_UP:
        servo[rightFinger] = RSERVO_DOCK_FINGER_UP;
        servo[leftFinger]  = LSERVO_DOCK_FINGER_UP;
       break;
    case DOCK_FINGER_DOWN:
        servo[rightFinger] = RSERVO_DOCK_FINGER_DOWN;
        servo[leftFinger]  = LSERVO_DOCK_FINGER_DOWN;
        break;
    }
}

void conveyor_enter_state(conveyor_state_t state)
{
    conveyor_state = state;

    switch (state) {
    case CONVEYOR_OFF:
        motor[conveyor] = 0;
        break;
    case CONVEYOR_FORWARD:
        motor[conveyor] = CONVEYOR_POWER;
        break;
    case CONVEYOR_BACKWARD:
        motor[conveyor] = -CONVEYOR_POWER;
        break;
    }
}

void initializeRobot()
{
    conveyor_enter_state(CONVEYOR_OFF);
    dock_enter_state(DOCK_FINGER_STOWED);

    servo[roller] = SERVO_ROLLER_DOWN;

    all_stop();

    return;
}

void handle_joy1_btn1()
{
    switch (conveyor_state) {
    case CONVEYOR_FORWARD:
        conveyor_enter_state(CONVEYOR_OFF);
        break;
    case CONVEYOR_BACKWARD:
        conveyor_enter_state(CONVEYOR_FORWARD);
        break;
    case CONVEYOR_OFF:
        conveyor_enter_state(CONVEYOR_FORWARD);
        break;
    }
}

void handle_joy1_btn4()
{
    switch (conveyor_state) {
    case CONVEYOR_FORWARD:
        conveyor_enter_state(CONVEYOR_BACKWARD);
        break;
    case CONVEYOR_BACKWARD:
        conveyor_enter_state(CONVEYOR_OFF);
        break;
    case CONVEYOR_OFF:
        conveyor_enter_state(CONVEYOR_BACKWARD);
        break;
    }
}

void handle_joy1_ltu()
{
    switch (dock_state) {
    case DOCK_FINGER_STOWED:
    case DOCK_FINGER_DOWN:
        dock_enter_state(DOCK_FINGER_UP);
        break;
    case DOCK_FINGER_UP:
         break;
    }
}

void handle_joy1_ltd()
{
    switch (dock_state) {
    case DOCK_FINGER_STOWED:
    case DOCK_FINGER_UP:
        dock_enter_state(DOCK_FINGER_DOWN);
        break;
    case DOCK_FINGER_DOWN:
        break;
    }
}

void handle_joy1_btn10()
{
    servo[roller] = SERVO_ROLLER_UP;
}


void handle_joy1_event(joystick_event_t event)
{
    switch (event) {
    case BUTTON_ONE:
        handle_joy1_btn1();
        break;
    case BUTTON_FOUR:
        handle_joy1_btn4();
        break;
    case BUTTON_TEN:
		handle_joy1_btn10();
		break;
    case LEFT_TRIGGER_UP:
        handle_joy1_ltu();
        break;
    case LEFT_TRIGGER_DOWN:
        handle_joy1_ltd();
        break;
    }

    startTask(debounceTask);
}



task main()
{
    short right_y;
    short left_y;

    debounce = false;

    initializeRobot();

    waitForStart();   // wait for start of tele-op phase

    // StartTask(endGameTimer);

    while (true) {

        getJoystickSettings(joystick);

        if (!debounce) {
	        if (joy1Btn(Btn1)) {
	            handle_joy1_event(BUTTON_ONE);
	        } else if (joy1Btn(Btn4)) {
	            handle_joy1_event(BUTTON_FOUR);
	        } else if (joy1Btn(Btn10)) {
        		handle_joy1_event(BUTTON_TEN);
	        } else if (joy1Btn(Btn5)) {
	            handle_joy1_event(LEFT_TRIGGER_UP);
	        } else if (joy1Btn(Btn7)) {
	            handle_joy1_event(LEFT_TRIGGER_DOWN);
	        } else if (joy1Btn(Btn6)) {
	        	motor[elbow]=100;
	        } else if (joy1Btn(Btn8)) {
	        	motor[elbow]=-100;
	        } else {
	        	motor[elbow]=0;
	        }
        }

        //if (drive_multiplier) {
            //right_y = joystick.joy1_y2;
            //left_y = joystick.joy1_y1;
        //} else {
            left_y = joystick.joy1_y1;
            right_y = joystick.joy1_y2;
        //}

        if (abs(right_y) > 20) {
	    	motor[driveFrontRight] = drive_multiplier * right_y;
	    	motor[driveRearRight] = drive_multiplier * right_y;
		}
		else {
		    motor[driveFrontRight] = 0;
		    motor[driveRearRight] = 0;
		}

        if (abs(left_y) > 20) {
		    motor[driveFrontLeft] = drive_multiplier * left_y;
		    motor[driveRearLeft] = drive_multiplier * left_y;
		}
		else
		{
		    motor[driveFrontLeft] = 0;
		    motor[driveRearLeft] = 0;
		}
    }
}
