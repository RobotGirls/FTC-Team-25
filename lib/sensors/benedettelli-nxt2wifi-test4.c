#pragma config(Sensor, S1,     TOUCH,          sensorTouch)
#pragma config(Sensor, S2,     COLOUR,         sensorCOLORFULL)
#pragma config(Sensor, S3,     SONAR,          sensorSONAR)
#pragma config(Sensor, S4,     NXT2WIFI,       sensorHighSpeed)
#pragma config(Motor,  motorA,          MOT_ACTION,          tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorB,          MOT_LEFT,          tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          MOT_RIGHT,          tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/common.h"
#include "drivers/benedettelli-nxt2wifi.h"

#define DRIVESPEED  50
#define TURNSPEED   20
#define SHOOTSPEED  30

string IPaddress = "0.0.0.0";
string connStatus = "disconnected";
string dataStrings[5];
tHugeByteArray data;

int prevDetectedColour = 0;
int currDetectedColour = 0;

int prevBatteryLevel = 0;
int currBatteryLevel = 0;

int prevTouchState = 0;
int currTouchState = 0;

int prevSonarDistance = 0;
int currSonarDistance = 0;

long prevEncMotorA = 0;
long currEncMotorA = 0;
long prevEncMotorB = 0;
long currEncMotorB = 0;
long prevEncMotorC = 0;
long currEncMotorC = 0;


task updateScreen()
{
  while(true)
  {
    nxtDisplayTextLine(0, "Stat: %s", connStatus);
    nxtDisplayTextLine(1, "%s",IPaddress);
    nxtDisplayTextLine(2, "-------------------");
    nxtDisplayTextLine(3, "%s", dataStrings[0]);
		nxtDisplayTextLine(4, "%s", dataStrings[1]);
		nxtDisplayTextLine(5, "%s", dataStrings[2]);
		nxtDisplayTextLine(6, "%s", dataStrings[3]);
    nxtDisplayTextLine(7, "%s", dataStrings[4]);
    wait1Msec(100);
  }
}

void handleColour(ubyte state)
{
  switch (state)
  {
    case 3: SensorType[COLOUR] = sensorCOLORFULL;
            break;
    case 4: SensorType[COLOUR] = sensorCOLORRED;
            break;
    case 5: SensorType[COLOUR] = sensorCOLORGREEN;
            break;
    case 6: SensorType[COLOUR] = sensorCOLORBLUE;
            break;
    case 7: SensorType[COLOUR] = sensorCOLORNONE;
            break;
  }
}

void doStraight(ubyte state)
{
  motor[MOT_LEFT]  = state * DRIVESPEED;
  motor[MOT_RIGHT] = state * DRIVESPEED;
}

void doRight(ubyte state)
{
  motor[MOT_LEFT]  = state *   TURNSPEED;
  motor[MOT_RIGHT] = state * -TURNSPEED;
}

void doStop(ubyte state)
{
  motor[MOT_LEFT]  = 0;
  motor[MOT_RIGHT] = 0;
}

void doLeft(ubyte state)
{
  motor[MOT_LEFT]  = state * -TURNSPEED;
  motor[MOT_RIGHT] = state *  TURNSPEED;
}

void doReverse(ubyte state)
{
  motor[MOT_LEFT]  = state * -DRIVESPEED;
  motor[MOT_RIGHT] = state * -DRIVESPEED;
}

void doAction(ubyte state)
{
  motor[MOT_ACTION] = state * SHOOTSPEED;
}


task main ()
{
  ubyte btnID;
  ubyte state;
  string dataString;
  string tmpString;

  // initialise the port, etc
  N2WInitLib();

  StartTask(updateScreen);

  // Disconnect if already connected
  N2WDisconnect();
  N2WchillOut();

  // if a custom profile exists, use that instead
  if (N2WCustomExist())
  {
    N2WLoad();
  }
  else
  {
    // enable DHCP
    N2WsetDHCP(true);
    wait1Msec(100);
    // Disable adhoc
	  N2WsetAdHoc(false);
	  wait1Msec(100);
	  // SSID to connect to
	  N2WsetSSID("YOURWIFINETWORK");
	  wait1Msec(100);
	  // The passphrase to use
	  N2WSecurityWPA2Passphrase("YOURWIFIPASSPHRASE");
	  wait1Msec(100);
	  // Save this profile to the custom profile
	  N2WSave();
	  wait1Msec(100);
	  // Load the custom profile
	  N2WLoad();
	}

  wait1Msec(100);
  N2WConnect(true);
  connStatus = "connecting";

  while (!N2WConnected())
    wait1Msec(1000);

  connStatus = "connected";
  PlaySound(soundBeepBeep);

  wait1Msec(3000);
  N2WgetIP(IPaddress);

  wait1Msec(1000);
  //                123456789012345
  dataStrings[0] = "Tch | Snr | Clr";
  //                on  | 011 |   1"
  while (true)
  {
    if (N2WreadWS(btnID, state))
    {

      writeDebugStreamLine("btn: %d, state: %d", btnID, state);
      switch (btnID)
      {
		    case 1: doStraight(state); break;
		    case 3: doRight(state); break;
		    case 4: doStop(state); break;
		    case 5: doLeft(state); break;
		    case 7: doReverse(state); break;
		    case 9: doAction(state); break;
        case 11: handleColour(state); break;
        default: break;
      }
    }

    // All values are only updated when they've changed.
    // This cuts backs drastically on the number of messages
    // that have to be sent to the NXT2WIFI

    // Fetch the state of the Touch Sensor
    // This value is displayed by field 0 (in0) on the page
    currTouchState = SensorValue[TOUCH];
    if (currTouchState != prevTouchState)
    {
      sprintf(dataString, "%d", currTouchState);
		  memcpy(data, dataString, strlen(dataString));
		  N2WwriteWS(0, data, strlen(dataString));
		  prevTouchState = currTouchState;
		  N2WchillOut();
    }

    // Fetch the currently detected colour.
    // This value is displayed by field 1 (in1) on the page
    currDetectedColour = SensorValue[COLOUR];
    if (currDetectedColour != prevDetectedColour)
    {
      sprintf(dataString, "%d", currDetectedColour);
		  memcpy(data, dataString, strlen(dataString));
		  N2WwriteWS(1, data, strlen(dataString));
		  prevDetectedColour = currDetectedColour;
		  N2WchillOut();
    }

    // Fetch the distance detected by the sonar sensor
    // This value is displayed by field 2 (in2) on the page
    currSonarDistance = SensorValue[SONAR];
    if (currSonarDistance != prevSonarDistance)
    {
      sprintf(dataString, "%d", currSonarDistance);
		  memcpy(data, dataString, strlen(dataString));
		  N2WwriteWS(2, data, strlen(dataString));
		  prevSonarDistance = currSonarDistance;
		  N2WchillOut();
    }

    // Fetch the tacho count for motor A
    // This value is displayed by field 3 (in3) on the page
    currEncMotorA = nMotorEncoder[MOT_ACTION];
    if (currEncMotorA != prevEncMotorA)
    {
      sprintf(dataString, "%d", currEncMotorA);
		  memcpy(data, dataString, strlen(dataString));
		  N2WwriteWS(3, data, strlen(dataString));
		  prevEncMotorA = currEncMotorA;
		  N2WchillOut();
    }

    // Fetch the tacho count for motor B
    // This value is displayed by field 4 (in4) on the page
    currEncMotorB = nMotorEncoder[MOT_LEFT];
    if (currEncMotorB != prevEncMotorB)
    {
      sprintf(dataString, "%d", currEncMotorB);
		  memcpy(data, dataString, strlen(dataString));
		  N2WwriteWS(4, data, strlen(dataString));
		  prevEncMotorB = currEncMotorB;
		  N2WchillOut();
    }

    // Fetch the tacho count for motor C
    // This value is displayed by field 5 (in5) on the page
    currEncMotorC = nMotorEncoder[MOT_RIGHT];
    if (currEncMotorC != prevEncMotorC)
    {
      sprintf(dataString, "%d", currEncMotorC);
		  memcpy(data, dataString, strlen(dataString));
		  N2WwriteWS(5, data, strlen(dataString));
		  prevEncMotorC = currEncMotorC;
		  N2WchillOut();
    }

    // Fetch the current voltage level.  The average one
    // works best, the other one jumps around too much.
    // This value is displayed by field 6 (in6) on the page

    currBatteryLevel = nAvgBatteryLevel;
    if (currBatteryLevel != prevBatteryLevel)
    {
      sprintf(dataString, "%d", currBatteryLevel);
		  memcpy(data, dataString, strlen(dataString));
		  N2WwriteWS(6, data, strlen(dataString));
		  prevBatteryLevel = currBatteryLevel;
		  N2WchillOut();
    }

    sprintf(dataStrings[2], "A: %d", currEncMotorA);
    sprintf(dataStrings[3], "B: %d", currEncMotorB);
    sprintf(dataStrings[4], "C: %d", currEncMotorC);
	  sprintf(tmpString, "%s | %3d", (currTouchState == 0) ? "off" : "on ", currSonarDistance);
	  sprintf(dataStrings[1], "%s | %3d", tmpString, currDetectedColour);
  }
}
